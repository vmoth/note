service register

1. service may up and down, and register center should konw this events
2. client should know which address should go to health node
3. Some microservice instance might take some time to start up; that is, just because
   they can receive HTTP requests

* 分布式服务无状态
无状态是指不保存存储状态，可以随意重启和替代，便于做扩展。
如果一个查询的结果是空（不管是数据不存在，还是系统故障），
我们仍把这个空结果进行缓存，但他的过期时间会很短， 最长不超过五分钟
## 加锁或者队列的方式保证缓存的单线程写

## 幂等-调用一次和调用多次结果是一样的

## CAP
1. C : 分布式系统中的所有数据备份，在统一时刻是否有同样的值
2. A : 集群中一部分节点故障后，集群整体是否能响应客户的读写请求
3. P : 系统如果不能在一定时限内达成数据一致性，就意味着发生了分区，就

### kafka

### Kafka的若干个Broker成功地接收到一条消息并写入到日志文件后，他们会告诉生产者这条消息已经成功提交。可以配置成一个Broker接收到消息就算已经提交，也可以配置成所有Broker收到消息再算提交

### “有限度的持久化保证” 地球不复存在那么只能在外星球部署kafka服务器

### 常见的消息丢失的案例
1. 发送者丢失消息 异步发送消息， “fire and forget” ，如果是异步，就使用producer.send(msg, callback)
2. 接收者丢失消息，先消费再更新offset，来最大限度的保证消息不丢失，但是这样会代理消息重复的问题。

### kafka 生产者幂等
* 作用范围：
1. 只能一个分区上的幂等
2. 只能单会话幂等，producer重启后，幂等不复存在

* 如何实现多分区多回话的幂等？
答案：使用事物 transaction

* kafka 事物
数据库ACID
- Atomicity 原子性
- Consistency 一致性
- Isolation 隔离性
- Durability 持久性

### 事物型Producer能够保证消息原子性地写入到多个分区中

cache aside
- 先查看内存中是否有数据
- 如果有将缓存数据给到返回
- 如果没有则查询数据
- 应用将结果写入缓存

* 如何更新？
- 先更新数据库
- 再使得缓存失效

* 为什么不先失效缓存？
- 如果先失效缓存，再更新数据库，再中间状态另一个请求发现缓存失效，去取数据库中
  的数据，但是这个数据不是最新的，随后更新缓存，会导致缓存中的数据一只不是最新的
* 为什么是令缓存失效？
- 两个


write through

### CAP
- Consistency 客户端不管访问哪个节点，要么读到的都是同一份最新的数据，要么读取失败
- Availability 尽力返回数据，不保证数据是最新的
- 分区容忍性 当节点内部出现任意数量的消息丢失或者延迟高的时候，系统仍然可以继续提供服务。
  强调集群对分区故障的容忍能力

### 节点分区故障是必然发生的
### 只有再发生分区故障的时候，才会再C和A之间作出选择。

### 两段提交
- 第一阶段，每个彩玉投票表决事务是放弃还是提交。一旦参与投票者投票要求提交事务
  那么就不允许放弃事务。
- 在一个参与投票

### TCC
- 两段提交需要预留资源，在资源预留期间，其他人不能操作


## Paxos 算法
- [n, v] n 提案编号，v 提议值

### 两个阶段
- Prepare 只需要提案的编号
  提议者发起提案，接收者接收提案。接收者判断接收到的提案，如果小于当然接收到的
  提案则不响应，如果
- 如果接收者之前有通过的议案，那么接收着会在准备请求的响应中包含已经通过的最大
  编号的提案信息



垃圾回收器有哪些？
- Serial
- Parallel
- CMS
- G1
